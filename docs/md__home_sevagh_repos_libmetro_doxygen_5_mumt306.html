<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmetro: MUMT-306 project report</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmetro
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_sevagh_repos_libmetro_doxygen_5_mumt306.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MUMT-306 project report </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objectives</h2>
<p>My original objective was to write a polyrhythmic metronome. As I started working on libmetro, the objectives became more concrete:</p>
<ol type="1">
<li>Write a library for building basic metronomes i.e. set a bpm for a sine wave click track. The cornerstone of libmetro is the use of a real-time audio library, <a href="http://libsound.io/">http://libsound.io/</a>. To use it effectively, I had to learn how to use ringbuffers and other techniques of real-time audio code.</li>
<li>Support additional timbres by using <a href="https://github.com/thestk/stk">https://github.com/thestk/stk</a> drum sounds. This is important when playing simultaneous rhythms (e.g. 4:3) to distinguish each rhythm by timbre.</li>
<li>Learn (some of) the theory behind rhythm and time signatures, and implement them alongside the basic click track e.g. polyrhythms, compound time.</li>
<li>Ensure the resulting code is easy to read and understand - don't let the ugly bits of C++ show too much.</li>
<li>Ensure the underlying code of the library is as correct and well-behaved as possible by testing and verifying the code using industry best practices. Users should only focus on whether or not their metronomes sound good, and not need to debug a segmentation fault, undefined behavior, or a memory leak.</li>
</ol>
<h2>Methodology</h2>
<h3>Real-time audio</h3>
<p>The following articles are a good introduction to the challenges of real-time audio code:</p>
<ul>
<li><a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing</a></li>
<li><a href="http://atastypixel.com/blog/four-common-mistakes-in-audio-development/">http://atastypixel.com/blog/four-common-mistakes-in-audio-development/</a></li>
</ul>
<p>The gist of is that the audio callback thread - the code that's sending audio data directly to the sound device - should only ever send audio to the sound device. Any code that has no guaranteed execution times (e.g. network calls, waiting for mutexes, sleeps, bad algorithms) might interrupt the audio callback thread from executing, and that's a big no-no - it can lead to glitchy audio or worse.</p>
<p>Since a metronome is timer-based, I make use of sleeps heavily in the code. In practice, libmetro's timer-based execution is kept separate from the audio callback thread - the two components communicate with a <a href="https://libsoundio.dpldocs.info/soundio.soundio.SoundIoRingBuffer.html">ringbuffer</a>. Here's a high-level diagram describing how a click track works in libmetro:</p>
<img src="./static/ringbuf.png" width="654" height="300" alt="" class="inline"/>
<p>The soundio code in libmetro has been adapted mostly unchanged from the <a href="https://github.com/andrewrk/libsoundio/tree/master/example">soundio examples</a>.</p>
<h3>Evolution of libmetro's UX</h3>
<h4>V0: too much C++</h4>
<p>The original UX seemed fine... to me. The person who spent 100% of their time writing 100% of the code. Taking a step back, the idea of asking "non-technical users" to write <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> to create a metronome would most likely discourage many users. I exposed parts of libmetro that still exist today - but the user need not be aware of them. It was possible to encapsulate them more neatly.</p>
<p>Original 4/4 drum track:</p>
<div class="fragment"><div class="line">int bpm = std::stoi(argv[1]);</div><div class="line">auto tempo = metro::Tempo(bpm);</div><div class="line"></div><div class="line">auto audio_engine = metro::audio::Engine();</div><div class="line">auto stream = audio_engine.new_outstream(tempo.period_us);</div><div class="line"></div><div class="line">auto hihat = metro::timbre::Drum(42, 100);</div><div class="line">auto snare = metro::timbre::Drum(38, 100);</div><div class="line">auto bass = metro::timbre::Drum(45, 100);</div><div class="line"></div><div class="line">metro::Measure beat22(std::vector&lt;metro::QuarterNote&gt;({</div><div class="line">    [&amp;]() {</div><div class="line">        stream.play_timbres({&amp;hihat, &amp;snare});</div><div class="line">    },</div><div class="line">    [&amp;]() { stream.play_timbres({&amp;hihat}); },</div><div class="line">    [&amp;]() {</div><div class="line">        stream.play_timbres({&amp;hihat, &amp;bass});</div><div class="line">    },</div><div class="line">    [&amp;]() { stream.play_timbres({&amp;hihat}); },</div><div class="line">}));</div><div class="line"></div><div class="line">tempo.register_measure(beat22);</div><div class="line">tempo.start();</div><div class="line"></div><div class="line">audio_engine.eventloop();</div></div><!-- fragment --><p>This doesn't seem horrendously complex, but the lambda syntax (i.e. <code>[&amp;]() { }</code>) is new to C++ in the 2011 standard, so making it a mandatory part of libmetro's user-facing functionality did not make sense.</p>
<h4>V1: too much music</h4>
<p>After learning a tiny bit about time signatures (mostly from YouTube tutorials), I went too far. I created many separate ticking timers in the metronome object, distinguished by their note duration.</p>
<p>I defined an enum with the values Whole, Half, HalfTriplet, Quarter, QuarterTriplet, Eighth, EighthTriplet, Sixteenth, SixteenthTriplet, each with a separate bpm computed from the input bpm (expected to be the quarter note bpm).</p>
<p>My first 3:2 polyrhythm is one where I threw together 3 "QuarterTriplet" notes and 2 "Quarter" notes and expected things to Just Work. This is what it sounded like:</p>
<p> 
<audio controls="1">
  <source src="./static/bad_poly32.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>This is what the code looked like:</p>
<div class="fragment"><div class="line">auto metronome = metro::Metronome(bpm);</div><div class="line"></div><div class="line">auto poly1 = metro::Measure(2);</div><div class="line">poly1[0] = metro::Note(metro::Note::Timbre::Drum, 185.0, 100.0)</div><div class="line">           + metro::Note(metro::Note::Timbre::Drum, 207.65, 100.0);</div><div class="line">poly1[1] = metro::Note(metro::Note::Timbre::Drum, 207.65, 50.0);</div><div class="line"></div><div class="line">metronome.add_measure(metro::Measure::NoteLength::Quarter, poly1);</div><div class="line"></div><div class="line">auto poly2 = metro::Measure(3);</div><div class="line">poly2[0] = metro::Note(metro::Note::Timbre::Drum, 73.42, 100.0)</div><div class="line">           + metro::Note(metro::Note::Timbre::Drum, 92.50, 100.0);</div><div class="line">poly2[1] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);</div><div class="line">poly2[2] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);</div><div class="line"></div><div class="line">metronome.add_measure(</div><div class="line">    metro::Measure::NoteLength::QuarterTriplet, poly2);</div><div class="line">metronome.start_and_loop();</div></div><!-- fragment --><p>I quickly realized that being too clever with a topic (rhythm, time signatures, beats) that I am a complete newbie to was absolutely futile.</p>
<h4>V2: just right</h4>
<p>The final UX of libmetro is more "automated manual" than fully-automatic-but-incorrect as in V1. When following YouTube tutorials on how one should create a 3:2 or 4:3 polyrhythm by considering the least common multiple, I reverted to exposing a single timer, and expect that the user should lay the beats out in a measure - probably the way that they already know a 4:3 works.</p>
<p>This led to the simplest code, and the best sounding metronomes.</p>
<div class="fragment"><div class="line">auto metronome = metro::Metronome(100);</div><div class="line"></div><div class="line">// lcm of 3 and 4 is 12</div><div class="line">auto measure = metro::Measure(12);</div><div class="line"></div><div class="line">measure[0] = downbeat1 + downbeat2;  // &lt;----- 1/4, 1/3</div><div class="line"></div><div class="line">measure[3] = weakbeat1;              // &lt;----- 2/4</div><div class="line">measure[6] = weakbeat1;              // &lt;----- 3/4</div><div class="line">measure[9] = weakbeat1;              // &lt;----- 4/4</div><div class="line"></div><div class="line">measure[4] = weakbeat2;              // &lt;----- 2/3</div><div class="line">measure[8] = weakbeat2;              // &lt;----- 3/3</div><div class="line"></div><div class="line">metronome.add_measure(measure);</div><div class="line">metronome.start_and_loop();</div></div><!-- fragment --><h4>V3: the experimental text file format</h4>
<p>I thought that the above example (V2) could be easily expressed in a text file, eliminating the need for users to write code at all. This is what it looks like:</p>
<div class="fragment"><div class="line">measure_length 12</div><div class="line"></div><div class="line">0 drum,73.42,100.0 drum,92.5,100.0 drum,207.65,100.0 drum,185.0,100.0</div><div class="line">3 drum,73.42,50.0</div><div class="line">4 drum,207.65,50.0</div><div class="line">6 drum,73.42,50.0</div><div class="line">8 drum,207.65,50.0</div><div class="line">9 drum,73.42,50.0</div></div><!-- fragment --><p>You can read more about it <a href="./md__home_sevagh_repos_libmetro_doxygen_2_txt_file_format.html">in this doc</a>.</p>
<h2>Tests and code quality tools</h2>
<h3>Unit tests</h3>
<p>The most critical aspect of a metronome is having an accurate timer. A naive ticker implementation is as follows:</p>
<div class="fragment"><div class="line">int bpm = 100;</div><div class="line"></div><div class="line">auto period_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div><div class="line">        std::chrono::duration&lt;double, std::micro&gt;(</div><div class="line">            1000000.0 * (60.0 / bpm)));</div><div class="line"></div><div class="line">// 100bpm period is 600,000 microseconds i.e. tick every 0.6s</div><div class="line"></div><div class="line">while (true) {</div><div class="line">        // insert code to play a click</div><div class="line">        std::this_thread::sleep_for(period_us);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The documentation for <a href="https://en.cppreference.com/w/cpp/thread/sleep_for"><code>std::this_thread::sleep_for</code></a> says:</p>
<p>&gt;&gt;&gt;Blocks the execution of the current thread for <em>at least</em> the specified sleep_duration. This function may block for longer than sleep_duration due to scheduling or resource contention delays.</p>
<p>Writing a unit test to measure the clock accuracy led me to discover how badly the naive ticker was drifting, and led to the creation of a more precise timer:</p>
<div class="fragment"><div class="line">void precise_sleep_us(std::chrono::microseconds dur_us)</div><div class="line">{</div><div class="line">        auto start_tick = std::chrono::steady_clock::now();</div><div class="line">        while (std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div><div class="line">                   std::chrono::steady_clock::now() - start_tick)</div><div class="line">               &lt; dur_us)</div><div class="line">                std::this_thread::sleep_for(std::chrono::nanoseconds(1));</div><div class="line">}</div></div><!-- fragment --><p>This might be familiar from the first exam - it's better to sleep in tiny amounts (since sleeping is non-premptible) to exercise finer-grained control over execution times. Here's an example of a naive ticker vs precise ticker, playing a 4-note measure that consists of 1 beep and 3 silences, at 500, 700, and 900bpm. Notice the out-of-sync beeps - that's the naive clock drifting away from the expected bpm:</p>
<p> 
<audio controls="1">
  <source src="./static/ticker_vs_ticker.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>The clock accuracy unit test verifies that the precise sleep stays within 2% clock drift (i.e. it ticks when it's expected to, +-2% at most). Of course, this is hardware and platform-dependent, but it's better than the naive clock.</p>
<h3>Undefined behavior, ubsan, asan</h3>
<p>Recall this from the class notes:</p>
<div class="fragment"><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned char&gt; bytes(2); //2-element vector</div><div class="line">  bytes[3] = 79;     // ERROR: attempt to write a value to the 4th element, which doesn&#39;t exist!!!</div><div class="line">  std::cout &lt;&lt; &quot;hello, world!&quot; &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>This doesn't create any errors in C++ using g++ or clang++ on my laptop (Fedora 30, Thinkpad T490):</p>
<div class="fragment"><div class="line">sevagh:ub-test $ g++ undefined_behavior.cpp</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">hello, world!</div><div class="line">sevagh:ub-test $ clang++ undefined_behavior.cpp</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">hello, world!</div></div><!-- fragment --><p>Why? This is <a href="https://en.cppreference.com/w/cpp/language/ub#Access_out_of_bounds">undefined behavior</a>. How are ways we can detect this? I know of two - <a href="http://valgrind.org/">valgrind</a> and <a href="https://clang.llvm.org/docs/AddressSanitizer.html">asan</a>.</p>
<p>Let's see valgrind in action. Code running under valgrind is slower, since valgrind executes lots of extra code for error instrumentation:</p>
<div class="fragment"><div class="line">sevagh:ub-test $ valgrind ./a.out</div><div class="line">==19643== Memcheck, a memory error detector</div><div class="line">==19643== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</div><div class="line">==19643== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</div><div class="line">==19643== Command: ./a.out</div><div class="line">==19643==</div><div class="line">==19643== Invalid write of size 1</div><div class="line">==19643==    at 0x4012B6: main (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==  Address 0x4da9c83 is 1 bytes after a block of size 2 alloc&#39;d</div><div class="line">==19643==    at 0x4838E86: operator new(unsigned long) (vg_replace_malloc.c:344)</div><div class="line">==19643==    by 0x401916: __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x4018BB: std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401862: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x4017BE: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_create_storage(unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401544: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;unsigned char&gt; const&amp;) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401388: std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::vector(unsigned long, std::allocator&lt;unsigned char&gt; const&amp;) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401299: main (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==</div><div class="line">hello, world!</div><div class="line">==19643==</div><div class="line">==19643== HEAP SUMMARY:</div><div class="line">==19643==     in use at exit: 0 bytes in 0 blocks</div><div class="line">==19643==   total heap usage: 3 allocs, 3 frees, 73,730 bytes allocated</div><div class="line">==19643==</div><div class="line">==19643== All heap blocks were freed -- no leaks are possible</div><div class="line">==19643==</div><div class="line">==19643== For lists of detected and suppressed errors, rerun with: -s</div><div class="line">==19643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</div></div><!-- fragment --><p>How about <code>asan</code>? To use asan, one must compile the code with special flags (initially implemented in clang, but now available in <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">gcc</a>):</p>
<div class="fragment"><div class="line">sevagh:ub-test $ clang++ undefined_behavior.cpp -fsanitize=address</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">=================================================================</div><div class="line">==20457==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000013 at pc 0x000000539212 bp 0x7ffde7ce1510 sp 0x7ffde7ce1508</div><div class="line">WRITE of size 1 at 0x602000000013 thread T0</div><div class="line">    #0 0x539211  (/home/sevagh/repos/ub-test/a.out+0x539211)</div><div class="line">    #1 0x7f8753600f42  (/lib64/libc.so.6+0x23f42)</div><div class="line">    #2 0x41c48d  (/home/sevagh/repos/ub-test/a.out+0x41c48d)</div><div class="line"></div><div class="line">0x602000000013 is located 1 bytes to the right of 2-byte region [0x602000000010,0x602000000012)</div><div class="line">allocated by thread T0 here:</div><div class="line">    #0 0x535c5f  (/home/sevagh/repos/ub-test/a.out+0x535c5f)</div><div class="line">    #1 0x53a01b  (/home/sevagh/repos/ub-test/a.out+0x53a01b)</div><div class="line">    #2 0x539fbb  (/home/sevagh/repos/ub-test/a.out+0x539fbb)</div><div class="line">    #3 0x539f62  (/home/sevagh/repos/ub-test/a.out+0x539f62)</div><div class="line">    #4 0x539d4e  (/home/sevagh/repos/ub-test/a.out+0x539d4e)</div><div class="line">    #5 0x5397a4  (/home/sevagh/repos/ub-test/a.out+0x5397a4)</div><div class="line">    #6 0x539418  (/home/sevagh/repos/ub-test/a.out+0x539418)</div><div class="line">    #7 0x5391b2  (/home/sevagh/repos/ub-test/a.out+0x5391b2)</div><div class="line">    #8 0x7f8753600f42  (/lib64/libc.so.6+0x23f42)</div><div class="line"></div><div class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/sevagh/repos/ub-test/a.out+0x539211)</div><div class="line">Shadow bytes around the buggy address:</div><div class="line">  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">=&gt;0x0c047fff8000: fa fa[02]fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</div><div class="line">  Addressable:           00</div><div class="line">  Partially addressable: 01 02 03 04 05 06 07</div><div class="line">  Heap left redzone:       fa</div><div class="line">  Freed heap region:       fd</div><div class="line">  Stack left redzone:      f1</div><div class="line">  Stack mid redzone:       f2</div><div class="line">  Stack right redzone:     f3</div><div class="line">  Stack after return:      f5</div><div class="line">  Stack use after scope:   f8</div><div class="line">  Global redzone:          f9</div><div class="line">  Global init order:       f6</div><div class="line">  Poisoned by user:        f7</div><div class="line">  Container overflow:      fc</div><div class="line">  Array cookie:            ac</div><div class="line">  Intra object redzone:    bb</div><div class="line">  ASan internal:           fe</div><div class="line">  Left alloca redzone:     ca</div><div class="line">  Right alloca redzone:    cb</div><div class="line">  Shadow gap:              cc</div><div class="line">==20457==ABORTING</div></div><!-- fragment --><p>Finally, <a href="https://lemire.me/blog/2016/04/20/no-more-leaks-with-sanitize-flags-in-gcc-and-clang/">here's an article</a> by one of industry's best systems programmers advising the use of <code>-fsanitize=address</code> and <code>-fsanitize=unknown</code>, both of which I use in libmetro (target: <code>make build-ubsan</code>) to avoid creating serious bugs.</p>
<h3>Other quality tools</h3>
<p>The target for <a href="https://clang.llvm.org/extra/clang-tidy/">clang-tidy</a> in libmetro is <code>make build-clang-tidy</code> (clang-tidy needs to run at compile time). clang-tidy and cppclean mostly provide suggestions for code clarity:</p>
<div class="fragment"><div class="line">/home/sevagh/repos/libmetro/build/../src/outstream.cpp:46:7: warning: implicit conversion &#39;struct SoundIoRingBuffer *&#39; -&gt; bool [readability-implicit-bool-conversion]</div><div class="line">        if (!ringbuf)</div></div><!-- fragment --><p>This might be a common idiom but it's not as explicit as <code>if (ringbuf != nullptr)</code>. <a href="https://en.cppreference.com/w/cpp/language/nullptr">nullptr in C++11</a> is a safer version of <code>NULL</code>.</p>
<p>Likewise, <a href="https://pypi.org/project/cppclean/">cppclean</a> (<code>make cpp-clean</code>) lets us avoid a few redundant header includes:</p>
<div class="fragment"><div class="line">/home/sevagh/repos/libmetro/src/metronome.cpp:2: &#39;outstream.h&#39; already #included in &#39;/home/sevagh/repos/libmetro/src/metronome.h&#39;</div></div><!-- fragment --><p><a href="https://clang-analyzer.llvm.org/">clang-analyze</a> (<code>make clang-analyze</code>) runs the entire cmake/ninja compilations under the <code>scanbuild</code> command:</p>
<div class="fragment"><div class="line">[5/16] Building CXX object CMakeFiles/metro.dir/src/timbregen.cpp.o</div><div class="line">../src/timbregen.cpp:106:2: warning: 2nd function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">../src/timbregen.cpp:106:2: warning: 3rd function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">../src/timbregen.cpp:106:2: warning: 4th function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></div><!-- fragment --><p>The problem in the code is in the text file format parser:</p>
<div class="fragment"><div class="line">metro::Note::Timbre timbre;</div><div class="line">float freq;</div><div class="line">float vol;</div><div class="line"></div><div class="line">// logic to parse the text file and extract values of timbre, freq, vol</div><div class="line"></div><div class="line">populate_frames(frames, timbre, freq, vol);</div></div><!-- fragment --><p>The problem is that if the parsing logic never reaches the code that sets those variables (entirely possible - pass it a blank file, an invalid file, etc.), those values are used uninitialized, and uninitialized values in C++ have <a href="https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory">unpredictable values</a> - it's that undefined behavior again.</p>
<p>Let's see it in a minimal example:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">class Airplane {</div><div class="line">public:</div><div class="line">        void set_cruising_altitude(float altitude) {</div><div class="line">                std::cout &lt;&lt; &quot;Setting airplane altitude to: &quot; &lt;&lt; altitude &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">};</div><div class="line"></div><div class="line">class Autopilot {</div><div class="line">public:</div><div class="line">        Autopilot(int knots) : knots(knots) { };</div><div class="line">        float get_cruising_altitude() {</div><div class="line">                return cruising_altitude;</div><div class="line">        }</div><div class="line">private:</div><div class="line">        int knots;</div><div class="line">        float cruising_altitude;</div><div class="line">};</div><div class="line"></div><div class="line">int main()</div><div class="line">{</div><div class="line">        auto plane = Airplane();</div><div class="line"></div><div class="line">        int desired_knots = 60;</div><div class="line">        auto autopilot = Autopilot(desired_knots);</div><div class="line"></div><div class="line">        plane.set_cruising_altitude(autopilot.get_cruising_altitude());</div><div class="line"></div><div class="line">        return 0;</div><div class="line">}</div></div><!-- fragment --><p>I chose ridiculously names in the example to make a somewhat serious point that bad C/C++ code is a real issue in safety-critical applications. In action:</p>
<div class="fragment"><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">Setting airplane altitude to: 4.59121e-41</div></div><!-- fragment --><h2>Results</h2>
<p>I'll refer you to the other subpages in these docs to hear libmetro in action:</p>
<ul>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_1_gettingstarted.html">Getting started</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_2_txt_file_format.html">Txt file format</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_3_simple_odd_compound.html">Simple, odd, compound time signatures</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_4_polyrhythms.html">Polyrhythm</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmetro: MUMT-306 project report</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmetro
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_sevagh_repos_libmetro_doxygen_5_mumt306.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MUMT-306 project report </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objectives</h2>
<p>My original objective was to write a polyrhythmic metronome. As I started working on libmetro, the objectives became more concrete:</p>
<ol type="1">
<li>Write a library for building basic metronomes i.e. set a bpm for a sine wave click track. The cornerstone of libmetro is the use of a real-time audio library, <a href="http://libsound.io/">http://libsound.io/</a>. To use it effectively, I had to learn how to use ringbuffers and other techniques of real-time audio code.</li>
<li>Support additional timbres by using <a href="https://github.com/thestk/stk">https://github.com/thestk/stk</a> drum sounds. This is important when playing simultaneous rhythms (e.g. 4:3) to distinguish each rhythm by timbre.</li>
<li>Learn (some of) the theory behind rhythm and time signatures, and implement them alongside the basic click track e.g. polyrhythms, compound time.</li>
<li>Ensure the resulting code is easy to read and understand - don't let the ugly bits of C++ show too much.</li>
<li>Ensure the underlying code of the library is as correct and well-behaved as possible by testing and verifying the code using industry best practices. Users should only focus on whether or not their metronomes sound good, and not need to debug a segmentation fault, undefined behavior, or a memory leak.</li>
</ol>
<h2>Methodology</h2>
<h3>Real-time audio</h3>
<p>The following articles are a good introduction to the challenges of real-time audio code:</p>
<ul>
<li><a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing</a></li>
<li><a href="http://atastypixel.com/blog/four-common-mistakes-in-audio-development/">http://atastypixel.com/blog/four-common-mistakes-in-audio-development/</a></li>
</ul>
<p>The code that's sending audio data directly to the sound device should not have any delays (e.g. network calls, waiting for mutexes, sleeps) to avoid the risk of glitchy audio or worse. Since a metronome is timer-based, I make use of sleeps heavily in the code. In practice, libmetro's timer-based note player is kept separate from the audio callback thread - the two components communicate with a <a href="https://libsoundio.dpldocs.info/soundio.soundio.SoundIoRingBuffer.html">ringbuffer</a> - <a href="https://github.com/sevagh/libmetro/blob/master/src/outstream.cpp#L107">source code here</a>.</p>
<p>I've recorded a clip of a polyrhythm played at an impractically high 1900bpm (31.58ms period) by libmetro. This should demonstrate that my timing assumptions and ringbuffer fill/drain strategy are working correctly at very low latencies:</p>
<p> 
<audio controls="1">
  <source src="./static/poly_35_swing_1900bpm.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>A downside of my code is that I had great difficulty implementing an example with a gradual tempo change without introducing glitchy audio, due to how I rely on libsoundio's <a href="http://libsound.io/doc-2.0.0/structSoundIoOutStream.html#a20aac1422d3cc64b679616bb8447f06d">software latency</a> parameter to make my timings work correctly. In one attempt I constantly created new metronome objects, which sort of worked, but the amount of hacks I had to add to the code made it not worthwhile to support.</p>
<h3>Evolution of libmetro's UX</h3>
<h4>V0: too much C++</h4>
<p>The first version of the UX exposed too much "wiring", e.g. requiring the users to write <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> to create a metronome. Original 4/4 drum track:</p>
<div class="fragment"><div class="line">int bpm = std::stoi(argv[1]);</div><div class="line">auto tempo = metro::Tempo(bpm);</div><div class="line"></div><div class="line">auto audio_engine = metro::audio::Engine();</div><div class="line">auto stream = audio_engine.new_outstream(tempo.period_us);</div><div class="line"></div><div class="line">auto hihat = metro::timbre::Drum(42, 100);</div><div class="line">auto snare = metro::timbre::Drum(38, 100);</div><div class="line">auto bass = metro::timbre::Drum(45, 100);</div><div class="line"></div><div class="line">metro::Measure beat22(std::vector&lt;metro::QuarterNote&gt;({</div><div class="line">    [&amp;]() {</div><div class="line">        stream.play_timbres({&amp;hihat, &amp;snare});</div><div class="line">    },</div><div class="line">    [&amp;]() { stream.play_timbres({&amp;hihat}); },</div><div class="line">    [&amp;]() {</div><div class="line">        stream.play_timbres({&amp;hihat, &amp;bass});</div><div class="line">    },</div><div class="line">    [&amp;]() { stream.play_timbres({&amp;hihat}); },</div><div class="line">}));</div><div class="line"></div><div class="line">tempo.register_measure(beat22);</div><div class="line">tempo.start();</div><div class="line"></div><div class="line">audio_engine.eventloop();</div></div><!-- fragment --><p>The lambda syntax (i.e. <code>[&amp;]() { }</code>) is new to C++ in the 2011 standard, so making it a necessary part of libmetro's UX was a bad decision.</p>
<h4>V1: too much music</h4>
<p>After learning a (very little) bit about time signatures (mostly from YouTube tutorials or asking classmates and friends), I went too far. I created a notion of "note durations", defined an enum with the values Whole, Half, HalfTriplet, Quarter, QuarterTriplet, Eighth, EighthTriplet, Sixteenth, SixteenthTriplet, each with a separate bpm computed from the input bpm (expected to be the quarter note bpm).</p>
<p>My first 3:2 polyrhythm is one where I threw together 3 "QuarterTriplet" notes and 2 "Quarter" notes and expected things to Just Work. This is what it sounded like:</p>
<p> 
<audio controls="1">
  <source src="./static/bad_poly32.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>This is what the code looked like:</p>
<div class="fragment"><div class="line">auto metronome = metro::Metronome(bpm);</div><div class="line"></div><div class="line">auto poly1 = metro::Measure(2);</div><div class="line">poly1[0] = metro::Note(metro::Note::Timbre::Drum, 185.0, 100.0)</div><div class="line">           + metro::Note(metro::Note::Timbre::Drum, 207.65, 100.0);</div><div class="line">poly1[1] = metro::Note(metro::Note::Timbre::Drum, 207.65, 50.0);</div><div class="line"></div><div class="line">metronome.add_measure(metro::Measure::NoteLength::Quarter, poly1);</div><div class="line"></div><div class="line">auto poly2 = metro::Measure(3);</div><div class="line">poly2[0] = metro::Note(metro::Note::Timbre::Drum, 73.42, 100.0)</div><div class="line">           + metro::Note(metro::Note::Timbre::Drum, 92.50, 100.0);</div><div class="line">poly2[1] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);</div><div class="line">poly2[2] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);</div><div class="line"></div><div class="line">metronome.add_measure(</div><div class="line">    metro::Measure::NoteLength::QuarterTriplet, poly2);</div><div class="line">metronome.start_and_loop();</div></div><!-- fragment --><p>Contrast with a correct 3:2:</p>
<p> 
<audio controls="1">
  <source src="./static/good_poly32.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>I realized that baking in my incomplete knowledge of music could create a dangerously incorrect library. Note that this is the same rationale for why I don't have any examples that automatically create metronomes based on input time signatures (I put in many, and removed them). Somebody with a better grasp on time signatures could create a better frontend for libmetro that does that.</p>
<h4>V2: just right</h4>
<p>The final UX of libmetro is more "automated manual" than fully-automatic-but-incorrect as in V1. When following YouTube tutorials on how one should create a 3:2 or 4:3 polyrhythm by considering the least common multiple, I reverted to exposing a single timer, and expect that the user should lay the beats out in a measure.</p>
<p>This led to the simplest code, and the best sounding metronomes.</p>
<div class="fragment"><div class="line">auto metronome = metro::Metronome(100);</div><div class="line"></div><div class="line">// lcm of 3 and 4 is 12</div><div class="line">auto measure = metro::Measure(12);</div><div class="line"></div><div class="line">measure[0] = downbeat1 + downbeat2;  // &lt;----- 1/4, 1/3</div><div class="line"></div><div class="line">measure[3] = weakbeat1;              // &lt;----- 2/4</div><div class="line">measure[6] = weakbeat1;              // &lt;----- 3/4</div><div class="line">measure[9] = weakbeat1;              // &lt;----- 4/4</div><div class="line"></div><div class="line">measure[4] = weakbeat2;              // &lt;----- 2/3</div><div class="line">measure[8] = weakbeat2;              // &lt;----- 3/3</div><div class="line"></div><div class="line">metronome.add_measure(measure);</div><div class="line">metronome.start_and_loop();</div></div><!-- fragment --><h4>V3: the experimental text file format</h4>
<p>I thought that the above example (V2) could be easily expressed in a text file, eliminating the need for users to write code at all. This is what it looks like:</p>
<div class="fragment"><div class="line">measure_length 12</div><div class="line"></div><div class="line"># [-------- downbeat1 -----------]+[--------- downbeat2 ------------]</div><div class="line">0 drum,73.42,100.0 drum,92.5,100.0 drum,207.65,100.0 drum,185.0,100.0</div><div class="line"></div><div class="line"># [- weakbeat1 -]</div><div class="line">3 drum,73.42,50.0</div><div class="line"></div><div class="line"># [- weakbeat2 -]</div><div class="line">4 drum,207.65,50.0</div><div class="line"></div><div class="line"># [- weakbeat1 -]</div><div class="line">6 drum,73.42,50.0</div><div class="line"></div><div class="line"># [- weakbeat2 -]</div><div class="line">8 drum,207.65,50.0</div><div class="line"></div><div class="line"># [- weakbeat1 -]</div><div class="line">9 drum,73.42,50.0</div></div><!-- fragment --><p>I also received a suggestion from Victor for an improved file format that's more intuitive:</p>
<div class="fragment"><div class="line">1 0 0 1 0 0 1 0 0 1 0 0</div><div class="line">1 0 0 0 1 0 0 0 1 0 0 0</div></div><!-- fragment --><p>You can read more about these formats <a href="./md__home_sevagh_repos_libmetro_doxygen_2_txt_file_format.html">in this doc</a>.</p>
<h2>Code quality</h2>
<h3>Unit tests</h3>
<p>The most critical aspect of a metronome is having an accurate timer. A naive ticker implementation is as follows:</p>
<div class="fragment"><div class="line">int bpm = 100;</div><div class="line"></div><div class="line">auto period_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div><div class="line">        std::chrono::duration&lt;double, std::micro&gt;(</div><div class="line">            1000000.0 * (60.0 / bpm)));</div><div class="line"></div><div class="line">// 100bpm period is 600,000 microseconds i.e. tick every 0.6s</div><div class="line"></div><div class="line">while (true) {</div><div class="line">        // insert code to play a click</div><div class="line">        std::this_thread::sleep_for(period_us);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The documentation for <a href="https://en.cppreference.com/w/cpp/thread/sleep_for"><code>std::this_thread::sleep_for</code></a> says:</p>
<p>&gt;&gt;&gt;Blocks the execution of the current thread for <em>at least</em> the specified sleep_duration. This function may block for longer than sleep_duration due to scheduling or resource contention delays.</p>
<p>Writing a unit test to measure the clock accuracy led me to discover how badly the naive ticker was drifting, and led to the creation of a more precise timer:</p>
<div class="fragment"><div class="line">void precise_sleep_us(std::chrono::microseconds dur_us)</div><div class="line">{</div><div class="line">        auto start_tick = std::chrono::steady_clock::now();</div><div class="line">        while (std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div><div class="line">                   std::chrono::steady_clock::now() - start_tick)</div><div class="line">               &lt; dur_us)</div><div class="line">                std::this_thread::sleep_for(std::chrono::nanoseconds(1));</div><div class="line">}</div></div><!-- fragment --><p>This might be familiar from the first exam - it's better to sleep in tiny amounts (since sleeping is non-premptible) to exercise finer-grained control over execution times. Here's an example of a naive ticker vs precise ticker, playing a 4-note measure that consists of 1 beep and 3 silences, at 500, 700, and 900bpm. Notice the out-of-sync beeps - that's the naive clock drifting away from the expected bpm:</p>
<p> 
<audio controls="1">
  <source src="./static/ticker_vs_ticker.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>The clock accuracy unit test verifies that the precise sleep stays within 2% clock drift (i.e. it ticks when it's expected to, +-2% at most). Of course, this is hardware and platform-dependent, but it's better than the naive clock.</p>
<h3>Undefined behavior, ubsan, asan</h3>
<p>Recall this from the class notes:</p>
<div class="fragment"><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned char&gt; bytes(2); //2-element vector</div><div class="line">  bytes[3] = 79;     // ERROR: attempt to write a value to the 4th element, which doesn&#39;t exist!!!</div><div class="line">  std::cout &lt;&lt; &quot;hello, world!&quot; &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>This doesn't create any errors in C++ using g++ or clang++ on my laptop (Fedora 30, Thinkpad T490):</p>
<div class="fragment"><div class="line">sevagh:ub-test $ g++ undefined_behavior.cpp</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">hello, world!</div><div class="line">sevagh:ub-test $ clang++ undefined_behavior.cpp</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">hello, world!</div></div><!-- fragment --><p>Why? This is <a href="https://en.cppreference.com/w/cpp/language/ub#Access_out_of_bounds">undefined behavior</a>. How are ways we can detect this? I know of two - <a href="http://valgrind.org/">valgrind</a> and <a href="https://clang.llvm.org/docs/AddressSanitizer.html">asan</a>.</p>
<p>Let's see valgrind in action. Code running under valgrind is slower, since valgrind executes lots of extra code for error instrumentation:</p>
<div class="fragment"><div class="line">sevagh:ub-test $ valgrind ./a.out</div><div class="line">==19643== Memcheck, a memory error detector</div><div class="line">==19643== Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</div><div class="line">==19643== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</div><div class="line">==19643== Command: ./a.out</div><div class="line">==19643==</div><div class="line">==19643== Invalid write of size 1</div><div class="line">==19643==    at 0x4012B6: main (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==  Address 0x4da9c83 is 1 bytes after a block of size 2 alloc&#39;d</div><div class="line">==19643==    at 0x4838E86: operator new(unsigned long) (vg_replace_malloc.c:344)</div><div class="line">==19643==    by 0x401916: __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x4018BB: std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401862: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x4017BE: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_create_storage(unsigned long) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401544: std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;unsigned char&gt; const&amp;) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401388: std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::vector(unsigned long, std::allocator&lt;unsigned char&gt; const&amp;) (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==    by 0x401299: main (in /home/sevagh/repos/ub-test/a.out)</div><div class="line">==19643==</div><div class="line">hello, world!</div><div class="line">==19643==</div><div class="line">==19643== HEAP SUMMARY:</div><div class="line">==19643==     in use at exit: 0 bytes in 0 blocks</div><div class="line">==19643==   total heap usage: 3 allocs, 3 frees, 73,730 bytes allocated</div><div class="line">==19643==</div><div class="line">==19643== All heap blocks were freed -- no leaks are possible</div><div class="line">==19643==</div><div class="line">==19643== For lists of detected and suppressed errors, rerun with: -s</div><div class="line">==19643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</div></div><!-- fragment --><p>How about <code>asan</code>? To use asan, one must compile the code with special flags (initially implemented in clang, but now available in <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">gcc</a>):</p>
<div class="fragment"><div class="line">sevagh:ub-test $ clang++ undefined_behavior.cpp -fsanitize=address</div><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">=================================================================</div><div class="line">==20457==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000013 at pc 0x000000539212 bp 0x7ffde7ce1510 sp 0x7ffde7ce1508</div><div class="line">WRITE of size 1 at 0x602000000013 thread T0</div><div class="line">    #0 0x539211  (/home/sevagh/repos/ub-test/a.out+0x539211)</div><div class="line">    #1 0x7f8753600f42  (/lib64/libc.so.6+0x23f42)</div><div class="line">    #2 0x41c48d  (/home/sevagh/repos/ub-test/a.out+0x41c48d)</div><div class="line"></div><div class="line">0x602000000013 is located 1 bytes to the right of 2-byte region [0x602000000010,0x602000000012)</div><div class="line">allocated by thread T0 here:</div><div class="line">    #0 0x535c5f  (/home/sevagh/repos/ub-test/a.out+0x535c5f)</div><div class="line">    #1 0x53a01b  (/home/sevagh/repos/ub-test/a.out+0x53a01b)</div><div class="line">    #2 0x539fbb  (/home/sevagh/repos/ub-test/a.out+0x539fbb)</div><div class="line">    #3 0x539f62  (/home/sevagh/repos/ub-test/a.out+0x539f62)</div><div class="line">    #4 0x539d4e  (/home/sevagh/repos/ub-test/a.out+0x539d4e)</div><div class="line">    #5 0x5397a4  (/home/sevagh/repos/ub-test/a.out+0x5397a4)</div><div class="line">    #6 0x539418  (/home/sevagh/repos/ub-test/a.out+0x539418)</div><div class="line">    #7 0x5391b2  (/home/sevagh/repos/ub-test/a.out+0x5391b2)</div><div class="line">    #8 0x7f8753600f42  (/lib64/libc.so.6+0x23f42)</div><div class="line"></div><div class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/sevagh/repos/ub-test/a.out+0x539211)</div><div class="line">Shadow bytes around the buggy address:</div><div class="line">  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">=&gt;0x0c047fff8000: fa fa[02]fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</div><div class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</div><div class="line">  Addressable:           00</div><div class="line">  Partially addressable: 01 02 03 04 05 06 07</div><div class="line">  Heap left redzone:       fa</div><div class="line">  Freed heap region:       fd</div><div class="line">  Stack left redzone:      f1</div><div class="line">  Stack mid redzone:       f2</div><div class="line">  Stack right redzone:     f3</div><div class="line">  Stack after return:      f5</div><div class="line">  Stack use after scope:   f8</div><div class="line">  Global redzone:          f9</div><div class="line">  Global init order:       f6</div><div class="line">  Poisoned by user:        f7</div><div class="line">  Container overflow:      fc</div><div class="line">  Array cookie:            ac</div><div class="line">  Intra object redzone:    bb</div><div class="line">  ASan internal:           fe</div><div class="line">  Left alloca redzone:     ca</div><div class="line">  Right alloca redzone:    cb</div><div class="line">  Shadow gap:              cc</div><div class="line">==20457==ABORTING</div></div><!-- fragment --><p>Finally, <a href="https://lemire.me/blog/2016/04/20/no-more-leaks-with-sanitize-flags-in-gcc-and-clang/">here's an article</a> (from a highly respected computer science professor) advising the use of <code>-fsanitize=address</code> and <code>-fsanitize=unknown</code>, both of which I use in libmetro (target: <code>make build-ubsan</code>) to try to detect bugs. Here's an example of asan I found <a href="https://github.com/systemd/systemd/pull/14096#issuecomment-557520188">in the wild</a> in the systemd project.</p>
<h3>Quality tools</h3>
<p>The simplest (but very effective) quality tool I use is <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a>, which is a code formatter. You should always have consistent source code formatting in a project. I borrowed my <code>.clang-format</code> file from a <a href="https://github.com/hotgloupi/8cube">good-looking codebase</a> which I found on GitHub.</p>
<p>The target for <a href="https://clang.llvm.org/extra/clang-tidy/">clang-tidy</a> in libmetro is <code>make build-clang-tidy</code> (clang-tidy needs to run at compile time). clang-tidy and cppclean mostly provide suggestions for code clarity:</p>
<div class="fragment"><div class="line">/home/sevagh/repos/libmetro/build/../src/outstream.cpp:46:7: warning: implicit conversion &#39;struct SoundIoRingBuffer *&#39; -&gt; bool [readability-implicit-bool-conversion]</div><div class="line">        if (!ringbuf)</div></div><!-- fragment --><p>This might be a common idiom but it's not as explicit as <code>if (ringbuf == nullptr)</code>. <a href="https://en.cppreference.com/w/cpp/language/nullptr">nullptr in C++11</a> is a safer version of <code>NULL</code>.</p>
<p>Likewise, <a href="https://pypi.org/project/cppclean/">cppclean</a> (<code>make cpp-clean</code>) lets us avoid a few redundant header includes:</p>
<div class="fragment"><div class="line">/home/sevagh/repos/libmetro/src/metronome.cpp:2: &#39;outstream.h&#39; already #included in &#39;/home/sevagh/repos/libmetro/src/metronome.h&#39;</div></div><!-- fragment --><p><a href="https://clang-analyzer.llvm.org/">clang-analyze</a> (<code>make clang-analyze</code>) runs the entire cmake/ninja compilations under the <code>scanbuild</code> command:</p>
<div class="fragment"><div class="line">[5/16] Building CXX object CMakeFiles/metro.dir/src/timbregen.cpp.o</div><div class="line">../src/timbregen.cpp:106:2: warning: 2nd function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">../src/timbregen.cpp:106:2: warning: 3rd function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">../src/timbregen.cpp:106:2: warning: 4th function call argument is an uninitialized value</div><div class="line">        populate_frames(frames, timbre, freq, vol);</div><div class="line">        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></div><!-- fragment --><p>The problem in the code is in the text file format parser:</p>
<div class="fragment"><div class="line">metro::Note::Timbre timbre;</div><div class="line">float freq;</div><div class="line">float vol;</div><div class="line"></div><div class="line">// logic to parse the text file and extract values of timbre, freq, vol</div><div class="line"></div><div class="line">populate_frames(frames, timbre, freq, vol);</div></div><!-- fragment --><p>The problem is that if the parsing logic never reaches the code that sets those variables (entirely possible - pass it a blank file, an invalid file, etc.), those values are used uninitialized, and uninitialized values in C++ have <a href="https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory">unpredictable values</a> - it's that undefined behavior again.</p>
<p>Let's see it in a minimal example:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">class Airplane {</div><div class="line">public:</div><div class="line">        void set_cruising_altitude(float altitude) {</div><div class="line">                std::cout &lt;&lt; &quot;Setting airplane altitude to: &quot; &lt;&lt; altitude &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">};</div><div class="line"></div><div class="line">class Autopilot {</div><div class="line">public:</div><div class="line">        Autopilot(int knots) : knots(knots) { };</div><div class="line">        float get_cruising_altitude() {</div><div class="line">                return cruising_altitude;</div><div class="line">        }</div><div class="line">private:</div><div class="line">        int knots;</div><div class="line">        float cruising_altitude;</div><div class="line">};</div><div class="line"></div><div class="line">int main()</div><div class="line">{</div><div class="line">        auto plane = Airplane();</div><div class="line"></div><div class="line">        int desired_knots = 60;</div><div class="line">        auto autopilot = Autopilot(desired_knots);</div><div class="line"></div><div class="line">        plane.set_cruising_altitude(autopilot.get_cruising_altitude());</div><div class="line"></div><div class="line">        return 0;</div><div class="line">}</div></div><!-- fragment --><p>I chose ridiculous names in the example to make the serious point that bad C/C++ code is problematic in safety-critical applications. In action:</p>
<div class="fragment"><div class="line">sevagh:ub-test $ ./a.out</div><div class="line">Setting airplane altitude to: 4.59121e-41</div></div><!-- fragment --><h3>C++ features and idioms</h3>
<p>I make some use of modern C++ features and common idioms.</p>
<p>I use the <a href="https://en.cppreference.com/w/cpp/language/pimpl">PIMPL idiom</a> to hide the implementation complexity of the Metronome class. In the public header file, Metronome is defined as:</p>
<div class="fragment"><div class="line">// forward declare the private implementation of Metronome</div><div class="line">namespace metro_private {</div><div class="line">class MetronomePrivate;</div><div class="line">};</div><div class="line"></div><div class="line">class Metronome {</div><div class="line">public:</div><div class="line">    Metronome(int bpm);</div><div class="line">    ~Metronome();</div><div class="line"></div><div class="line">    void add_measure(Measure&amp; measure);</div><div class="line">    void start();</div><div class="line">    void start_and_loop();</div><div class="line"></div><div class="line">private:</div><div class="line">    metro_private::MetronomePrivate* p_impl;</div><div class="line">};</div></div><!-- fragment --><p>Anybody reading the public header file to discover the usage of the Metronome class can see the public constructors and methods. This way, I can present a very neat public API of the Metronome, while hiding everything under the hood in <a href="https://github.com/sevagh/libmetro/blob/master/src/metronome.h">src/metronome.h</a>, <a href="https://github.com/sevagh/libmetro/blob/master/src/metronome.cpp">src/metronome.cpp</a>.</p>
<p>Another eyebrow-raising bit of code you'll see in libmetro is the <code>FRIEND_TEST</code> macro from <a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#testing-private-code">googletest</a>. This lets me test private class members, only when the code is compiled with the <code>UNIT_TESTS</code> macro:</p>
<div class="fragment"><div class="line">#ifdef UNIT_TESTS</div><div class="line">#include &lt;gtest/gtest_prod.h&gt;</div><div class="line">#endif /* UNIT_TESTS */</div><div class="line"></div><div class="line">namespace metro_private {</div><div class="line"></div><div class="line">class MetronomePrivate {</div><div class="line">public:</div><div class="line">    ...</div><div class="line"></div><div class="line">private:</div><div class="line">#ifdef UNIT_TESTS</div><div class="line">    FRIEND_TEST(MetronomePrivateUnitTest, EmptyAtInit);</div><div class="line">    FRIEND_TEST(MetronomePrivateUnitTest, AddMismatchedMeasuresLCMSize);</div><div class="line">    FRIEND_TEST(MetronomePrivateUnitTest,</div><div class="line">                DISABLED_TestStreamsDontUnderflowOrError);</div><div class="line">#endif /* UNIT_TESTS */</div><div class="line">    int bpm;</div><div class="line">    AudioEngine engine;</div><div class="line"></div><div class="line">    std::chrono::microseconds period_us;</div><div class="line">    OutStream stream;</div><div class="line">    std::thread ticker_thread;</div><div class="line"></div><div class="line">    std::atomic&lt;bool&gt; ticker_on;</div><div class="line">};</div><div class="line">}; // namespace metro_private</div></div><!-- fragment --><p>The <code>UNIT_TESTS</code> macro is enabled in the CMakeLists.txt file in the test target:</p>
<div class="fragment"><div class="line">...</div><div class="line">if(GTEST_FOUND)</div><div class="line">    add_executable(test_${name} test/${name}.cpp)</div><div class="line">    target_link_libraries(test_${name} ${METRO_TESTS_DEPS})</div><div class="line">    target_compile_definitions(test_${name} PUBLIC UNIT_TESTS )</div><div class="line"></div><div class="line">    add_test(test_${name} ${BIN_DIR}/test_${name})</div><div class="line">...</div></div><!-- fragment --><p>I make use of <a href="https://en.cppreference.com/w/cpp/thread/call_once">std::call_once and std::once_flag</a> to ensure that I only initialize stk once, since there's no global libmetro initialization function:</p>
<div class="fragment"><div class="line">static std::once_flag stk_init_flag;</div><div class="line"></div><div class="line">static void stk_init()</div><div class="line">{</div><div class="line">    std::call_once(stk_init_flag, []() {</div><div class="line">        stk::Stk::showWarnings(true);</div><div class="line">        stk::Stk::setSampleRate(metro::SampleRateHz);</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line">// note constructor</div><div class="line">metro::Note::Note(...) {</div><div class="line">    stk_init();</div><div class="line">}</div></div><!-- fragment --><p>Since users of libmetro will be repeatedly creating new Notes, and Notes are built from stk objects, std::call_once ensures that the stk initialization is done once the first Note is created, and then skipped afterwards.</p>
<p>I use <a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a> for a thread-safe <code>quit</code> boolean in my metronome ticker thread:</p>
<div class="fragment"><div class="line">void metro_private::MetronomePrivate::start()</div><div class="line">{</div><div class="line">    stream.start();</div><div class="line">    auto blocking_ticker = [&amp;](std::atomic&lt;bool&gt;&amp; on) {</div><div class="line">        while (on) {</div><div class="line">            std::thread([&amp;]() { stream.play_next_note(); }).detach();</div><div class="line">            metro_private::precise_sleep_us(period_us);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    ticker_thread = std::thread(blocking_ticker, std::ref(ticker_on));</div><div class="line">}</div><div class="line"></div><div class="line">void metro_private::MetronomePrivate::stop()</div><div class="line">{</div><div class="line">    ticker_on = false;</div><div class="line">    if (ticker_thread.joinable())</div><div class="line">        ticker_thread.join();</div><div class="line">}</div></div><!-- fragment --><p>This allows me to do a graceful shutdown of the thread.</p>
<p>I also use <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda expressions</a>, in the same code snippet pasted above (in fact, there are two nested lambdas - the blocking_ticker lambda is dispatching unnamed <code>play_next_note</code> lambdas):</p>
<div class="fragment"><div class="line">auto blocking_ticker = [&amp;](std::atomic&lt;bool&gt;&amp; on) {</div><div class="line">    while (on)</div><div class="line">        std::thread([&amp;]() { stream.play_next_note(); }).detach();</div><div class="line">};</div></div><!-- fragment --><p>Here's an excerpt from a <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019">Microsoft document</a> on typical lambda usage:</p>
<p>&gt;&gt;&gt;Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods.</p>
<p>By using lambda captures, I can capture all current references with the <code>[&amp;]</code> expression, so that I don't need to pass thread arguments piecemeal. Overall, code using lambdas is neat - right at the call-site, I define the code that I want to dispatch asynchronously, like the <code>play_next_note</code> method, which I fire in the background on every metronome tick.</p>
<h2>Results</h2>
<p>Here are a series of metronomes implemented with libmetro:</p>
<p>5/4</p>
<p> 
<audio controls="1">
  <source src="./static/54.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>9/8</p>
<p> 
<audio controls="1">
  <source src="./static/98.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>4:3</p>
<p> 
<audio controls="1">
  <source src="./static/poly_43_noclicks.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>Some complicated polyrhythm</p>
<p> 
<audio controls="1">
  <source src="./static/poly_35_swing.wav"
          type="audio/wav">
  </source>
</audio>
</p>
<p>Other subpages in these docs contain the full results, including usage docs and multiple examples:</p>
<ul>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_1_gettingstarted.html">Getting started</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_2_txt_file_format.html">Txt file format</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_3_simple_odd_compound.html">Simple, odd, compound time signatures</a></li>
<li><a href="./md__home_sevagh_repos_libmetro_doxygen_4_polyrhythms.html">Polyrhythm</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

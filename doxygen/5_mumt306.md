# MUMT-306 project report

## Objectives

My original objective was to write a polyrhythmic metronome. As I started working on libmetro, the objectives became more concrete:

1. Write a library for building basic metronomes i.e. set a bpm for a sine wave click track. The cornerstone of libmetro is the use of a real-time audio library, <http://libsound.io/>. To use it effectively, I had to learn how to use ringbuffers and other techniques of real-time audio code.
2. Support additional timbres by using <https://github.com/thestk/stk> drum sounds. This is important when playing simultaneous rhythms (e.g. 4:3) to distinguish each rhythm by timbre.
3. Learn (some of) the theory behind rhythm and time signatures, and implement them alongside the basic click track e.g. polyrhythms, compound time.
4. Ensure the resulting code is easy to read and understand - don't let the ugly bits of C++ show too much.
5. Ensure the underlying code of the library is as correct and well-behaved as possible by testing and verifying the code using industry best practices. Users should only focus on whether or not their metronomes sound good, and not need to debug a segmentation fault, undefined behavior, or a memory leak.

## Methodology

### 1. Real-time audio

The following articles are a good introduction to the challenges of real-time audio code:

* <http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing>
* <http://atastypixel.com/blog/four-common-mistakes-in-audio-development/>

The gist of is that the audio callback thread - the code that's sending audio data directly to the sound device - should only ever send audio to the sound device. Any code that has no guaranteed execution times (e.g. network calls, waiting for mutexes, sleeps, bad algorithms) might interrupt the audio callback thread from executing, and that's a big no-no - it can lead to glitchy audio or worse.

Since a metronome is timer-based, I make use of sleeps heavily in the code. In practice, libmetro's timer-based execution is kept separate from the audio callback thread - the two components communicate with a [ringbuffer](https://libsoundio.dpldocs.info/soundio.soundio.SoundIoRingBuffer.html). Here's a high-level diagram describing how a click track works in libmetro:

<img src="./static/ringbuf.png" width="654" height="300"/>

The soundio code in libmetro has been adapted mostly unchanged from the [soundio examples](https://github.com/andrewrk/libsoundio/tree/master/example).

### 2. Evolution of libmetro's UX

#### V0: too much C++

The original UX seemed fine... to me. The person who spent 100% of their time writing 100% of the code. Taking a step back, the idea of asking "non-technical users" to write [lambda functions](https://en.cppreference.com/w/cpp/language/lambda) to create a metronome would most likely discourage many users. I exposed parts of libmetro that still exist today - but the user need not be aware of them. It was possible to encapsulate them more neatly.

Original 4/4 drum track:

```
int bpm = std::stoi(argv[1]);
auto tempo = metro::Tempo(bpm);

auto audio_engine = metro::audio::Engine();
auto stream = audio_engine.new_outstream(tempo.period_us);

auto hihat = metro::timbre::Drum(42, 100);
auto snare = metro::timbre::Drum(38, 100);
auto bass = metro::timbre::Drum(45, 100);

metro::Measure beat22(std::vector<metro::QuarterNote>({
    [&]() {
        stream.play_timbres({&hihat, &snare});
    },
    [&]() { stream.play_timbres({&hihat}); },
    [&]() {
        stream.play_timbres({&hihat, &bass});
    },
    [&]() { stream.play_timbres({&hihat}); },
}));

tempo.register_measure(beat22);
tempo.start();

audio_engine.eventloop();
```

This doesn't seem horrendously complex, but the lambda syntax (i.e. `[&]() { }`) is new to C++ in the 2011 standard, so making it a mandatory part of libmetro's user-facing functionality did not make sense.

#### V1: too much music

After learning a tiny bit about time signatures (mostly from YouTube tutorials), I went too far. I created many separate ticking timers in the metronome object, distinguished by their note duration.

I defined an enum with the values Whole, Half, HalfTriplet, Quarter, QuarterTriplet, Eighth, EighthTriplet, Sixteenth, SixteenthTriplet, each with a separate bpm computed from the input bpm (expected to be the quarter note bpm).

My first 3:2 polyrhythm is one where I threw together 3 "QuarterTriplet" notes and 2 "Quarter" notes and expected things to Just Work. This is what it sounded like:

\htmlonly
<audio controls="1">
  <source src="./static/bad_poly32.wav"
          type="audio/wav">
  </source>
</audio>
\endhtmlonly

This is what the code looked like:

```
auto metronome = metro::Metronome(bpm);

auto poly1 = metro::Measure(2);
poly1[0] = metro::Note(metro::Note::Timbre::Drum, 185.0, 100.0)
           + metro::Note(metro::Note::Timbre::Drum, 207.65, 100.0);
poly1[1] = metro::Note(metro::Note::Timbre::Drum, 207.65, 50.0);

metronome.add_measure(metro::Measure::NoteLength::Quarter, poly1);

auto poly2 = metro::Measure(3);
poly2[0] = metro::Note(metro::Note::Timbre::Drum, 73.42, 100.0)
           + metro::Note(metro::Note::Timbre::Drum, 92.50, 100.0);
poly2[1] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);
poly2[2] = metro::Note(metro::Note::Timbre::Drum, 73.42, 50.0);

metronome.add_measure(
    metro::Measure::NoteLength::QuarterTriplet, poly2);
metronome.start_and_loop();
```

I quickly realized that being too clever with a topic (rhythm, time signatures, beats) that I am a complete newbie to was absolutely futile.

#### V2: just right

The final UX of libmetro is more "automated manual" than fully-automatic-but-incorrect as in V1. When following YouTube tutorials on how one should create a 3:2 or 4:3 polyrhythm by considering the least common multiple, I reverted to exposing a single timer, and expect that the user should lay the beats out in a measure - probably the way that they already know a 4:3 works.

This led to the simplest code, and the best sounding metronomes.

```
auto metronome = metro::Metronome(100);

// lcm of 3 and 4 is 12
auto measure = metro::Measure(12);

measure[0] = downbeat1 + downbeat2;  // <----- 1/4, 1/3

measure[3] = weakbeat1;              // <----- 2/4
measure[6] = weakbeat1;              // <----- 3/4
measure[9] = weakbeat1;              // <----- 4/4

measure[4] = weakbeat2;              // <----- 2/3
measure[8] = weakbeat2;              // <----- 3/3

metronome.add_measure(measure);
metronome.start_and_loop();
```

#### V3: the experimental text file format

I thought that the above example (V2) could be easily expressed in a text file, eliminating the need for users to write code at all. This is what it looks like:

```
measure_length 12

0 drum,73.42,100.0 drum,92.5,100.0 drum,207.65,100.0 drum,185.0,100.0
3 drum,73.42,50.0
4 drum,207.65,50.0
6 drum,73.42,50.0
8 drum,207.65,50.0
9 drum,73.42,50.0
```

You can read more about it [in this doc](./md__home_sevagh_repos_libmetro_doxygen_2_txt_file_format.html).

### 3. Tests and code quality tools

#### Unit tests

The most critical aspect of a metronome is having an accurate timer. A naive ticker implementation is as follows:

```
int bpm = 100;

auto period_us = std::chrono::duration_cast<std::chrono::microseconds>(
	    std::chrono::duration<double, std::micro>(
	        1000000.0 * (60.0 / bpm)));

// 100bpm period is 600,000 microseconds i.e. tick every 0.6s

while (true) {
        // insert code to play a click
        std::this_thread::sleep_for(period_us);
    }
}
```

The documentation for [`std::this_thread::sleep_for`](https://en.cppreference.com/w/cpp/thread/sleep_for) says:

>>>Blocks the execution of the current thread for _at least_ the specified sleep_duration. This function may block for longer than sleep_duration due to scheduling or resource contention delays.

Writing a unit test to measure the clock accuracy led me to discover how badly the naive ticker was drifting, and led to the creation of a more precise timer:

```
void precise_sleep_us(std::chrono::microseconds dur_us)
{
        auto start_tick = std::chrono::steady_clock::now();
        while (std::chrono::duration_cast<std::chrono::microseconds>(
                   std::chrono::steady_clock::now() - start_tick)
               < dur_us)
                std::this_thread::sleep_for(std::chrono::nanoseconds(1));
}
```

This might be familiar from the first exam - it's better to sleep in tiny amounts (since sleeping is non-premptible) to exercise finer-grained control over execution times. Here's an example of a naive ticker vs precise ticker, playing a 4-note measure that consists of 1 beep and 3 silences, at 500, 700, and 900bpm. Notice the out-of-sync beeps - that's the naive clock drifting away from the expected bpm:

\htmlonly
<audio controls="1">
  <source src="./static/ticker_vs_ticker.wav"
          type="audio/wav">
  </source>
</audio>
\endhtmlonly

The clock accuracy unit test verifies that the precise sleep stays within 2% clock drift (i.e. it ticks when it's expected to, +-2% at most). Of course, this is hardware and platform-dependent, but it's better than the naive clock.

#### Undefined behavior and ubsan

Recall this from the class notes:

```
#include <vector>
#include <iostream>

int main()
{
  std::vector<unsigned char> bytes(2); //2-element vector
  bytes[3] = 79;     // ERROR: attempt to write a value to the 4th element, which doesn't exist!!!
}
```

This doesn't create any errors in C++ using g++ or clang++ on my laptop:

```
```

Why? This is [undefined behavior](). Watch how a similar example segfaults in C with gcc and clang:

```
```

Simply put, g++ and gcc can decide to behave differently.
